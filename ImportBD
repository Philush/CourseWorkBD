-- This script was generated by a beta version of the ERD tool in pgAdmin 4.
-- Please log an issue at https://redmine.postgresql.org/projects/pgadmin4/issues/new if you find any bugs, including reproduction steps.
BEGIN;


CREATE TABLE IF NOT EXISTS public.author
(
    id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    lastname character varying(25) COLLATE pg_catalog."default" NOT NULL,
    firstname character varying(25) COLLATE pg_catalog."default" NOT NULL,
    date_birth date NOT NULL,
    CONSTRAINT author_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.book
(
    b_shifr text COLLATE pg_catalog."default" NOT NULL,
    name character varying(50) COLLATE pg_catalog."default" NOT NULL,
    author_id integer NOT NULL,
    theme character varying(20) COLLATE pg_catalog."default",
    genre character varying(20) COLLATE pg_catalog."default",
    count_pages integer,
    publisher_id integer NOT NULL,
    publish_year integer NOT NULL DEFAULT 2000,
    annotation text COLLATE pg_catalog."default",
    availability boolean NOT NULL DEFAULT true,
    CONSTRAINT book_pkey PRIMARY KEY (b_shifr),
    CONSTRAINT b_shifr CHECK (b_shifr SIMILAR TO '[a-zA-Z]{2}\d{5}')
);

CREATE TABLE IF NOT EXISTS public.publisher
(
    id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    name character varying(50) COLLATE pg_catalog."default" NOT NULL,
    street character varying(50) COLLATE pg_catalog."default" NOT NULL,
    house_num character varying(10) COLLATE pg_catalog."default" NOT NULL,
    build character varying(2) COLLATE pg_catalog."default",
    postal_code integer NOT NULL,
    phone_number character varying(12) COLLATE pg_catalog."default" NOT NULL,
    email character varying(50) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT publisher_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.reader
(
    id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    lastname character varying(30) COLLATE pg_catalog."default" NOT NULL,
    firstname character varying(30) COLLATE pg_catalog."default" NOT NULL,
    date_birth date NOT NULL,
    street character varying(50) COLLATE pg_catalog."default" NOT NULL,
    house_num character varying(10) COLLATE pg_catalog."default" NOT NULL,
    building character varying(3) COLLATE pg_catalog."default",
    flat integer,
    postal_code character varying(10) COLLATE pg_catalog."default" NOT NULL,
    phone_number character varying(12) COLLATE pg_catalog."default" NOT NULL,
    email character varying(50) COLLATE pg_catalog."default" NOT NULL,
    login character varying(10) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT reader_pkey PRIMARY KEY (id),
    CONSTRAINT reader_login_key UNIQUE (login)
);

CREATE TABLE IF NOT EXISTS public.rental
(
    id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    b_shifr text COLLATE pg_catalog."default" NOT NULL,
    date_issue date NOT NULL,
    date_return date,
    reader_id integer NOT NULL,
    CONSTRAINT rental_pkey PRIMARY KEY (id)
);

ALTER TABLE IF EXISTS public.book
    ADD CONSTRAINT book_author_id_fkey FOREIGN KEY (author_id)
    REFERENCES public.author (id) MATCH SIMPLE
    ON UPDATE CASCADE
    ON DELETE CASCADE
    NOT VALID;


ALTER TABLE IF EXISTS public.book
    ADD CONSTRAINT book_publisher_id_fkey FOREIGN KEY (publisher_id)
    REFERENCES public.publisher (id) MATCH SIMPLE
    ON UPDATE CASCADE
    ON DELETE CASCADE
    NOT VALID;


ALTER TABLE IF EXISTS public.rental
    ADD CONSTRAINT rental_b_shifr_fkey FOREIGN KEY (b_shifr)
    REFERENCES public.book (b_shifr) MATCH SIMPLE
    ON UPDATE CASCADE
    ON DELETE CASCADE
    NOT VALID;


ALTER TABLE IF EXISTS public.rental
    ADD CONSTRAINT rental_reader_id_fkey FOREIGN KEY (reader_id)
    REFERENCES public.reader (id) MATCH SIMPLE
    ON UPDATE CASCADE
    ON DELETE CASCADE
    NOT VALID;

END;


---------------

--Тригер и функция для заполнения проката
create or replace function createRental() returns trigger as
$$
declare

user_id integer;

begin

SELECT id INTO user_id FROM reader WHERE login = current_user;
IF (new.availability = False) 
THEN
INSERT INTO rental(b_shifr, date_issue, reader_id) VALUES (new.b_shifr, current_date, user_id);
ELSE 
UPDATE rental SET date_return = current_date WHERE b_shifr = new.b_shifr;
END IF;
return new;
end;
$$ language plpgsql;

create trigger createRental before update on book
for each row
when ( old.availability is DISTINCT FROM new.availability)
execute procedure createRental();


--Процедура добавления издательства
create or replace procedure addPublisher(
in nm publisher.name%type,
in st publisher.street%type,
in hn publisher.house_num%type,
in bu publisher.build%type,
in pc publisher.postal_code%type,
in pn publisher.phone_number%type,
in em publisher.email%type)

language 'plpgsql'

as $body$

begin
INSERT INTO publisher(name, street, house_num, build, postal_code, phone_number, email) VALUES (nm, st, hn, bu, pc, pn, em);
end; 
$body$;

--Процедура добавления автора
create or replace procedure addAuthor(
in ln author.lastname%type,
in fn author.firstname%type,
in db author.date_birth%type)

language 'plpgsql'

as $body$

begin
INSERT INTO author(lastname, firstname, date_birth) VALUES (ln, fn, db);
end; 
$body$;



--Процедура добавления книги 
create or replace procedure addBook(
in sh book.b_shifr%type,
in nm book.name%type,
in ai book.author_id%type,
in th book.theme%type,
in ge book.genre%type,
in cp book.count_pages%type,
in pi book.publisher_id%type,
in py book.publish_year%type,
in an book.annotation%type)

language 'plpgsql'

as $body$

begin
INSERT INTO book(b_shifr, name, author_id, theme, genre, count_pages, publisher_id, publish_year, annotation) VALUES (sh, nm, ai, th, ge, cp, pi, py, an);
end; 
$body$;




--Процедура добавления пользователя
create or replace procedure addReader(
in lstn reader.lastname%type,
in frtn reader.firstname%type,
in datebd reader.date_birth%type,
in st reader.street%type,
in hn reader.house_num%type,
in bu reader.building%type,
in fl reader.flat%type,
in pc reader.postal_code%type,
in pn reader.phone_number%type,
in em reader.email%type,
in lg reader.login%type)

language 'plpgsql'

as $body$

begin
INSERT INTO reader(lastname, firstname, date_birth, street, house_num, building, flat, postal_code, phone_number, email, login) VALUES (lstn, frtn, datebd, st, hn, bu, fl, pc, pn, em, lg);
end; 
$body$;


--Процедура удаления книги 
create or replace procedure delBook(
in sh book.b_shifr%type)

language 'plpgsql'

as $body$

begin

DELETE FROM book WHERE b_shifr = sh;

end; 
$body$;



--Процедура удаление автора
create or replace procedure delAuthor(
in idA author.id%type)

language 'plpgsql'

as $body$

begin

DELETE FROM author WHERE id = idA;

end; 
$body$;


--Процедура удаление издательства
create or replace procedure delPublisher(
in idP publisher.id%type)

language 'plpgsql'

as $body$

begin

DELETE FROM publisher WHERE idP = id;
end; 
$body$;

-- Процедура удаление читателя
create or replace procedure delReader(
in idR reader.id%type)

language 'plpgsql'

as $body$

begin

DELETE FROM reader WHERE id = idR;
end; 
$body$;

-------------------
-- CALL addpublisher('Эксмо', 'Полевая', '23', '1','800954','88005553535','aksmo@pub.ru');
-- CALL addpublisher('МИФ', 'Завокзальная', '45', '','682402','88005136794','mif@pub.ru');
-- CALL addPublisher('FanZon', 'Промышленная', '23', '6', '123456', '88887776655', 'fan@zon.ru');

-- CALL addauthor('Пушкин', 'Александр', '06.06.1799');
-- CALL addauthor('Толстой', 'Лев', '09.09.1828');
-- CALL addAuthor('Куанг', 'Ребекка', '29.05.1996');
-- CALL addAuthor('Рубанов', 'Андрей', '25.06.1969');

-- CALL addbook('RU00001', 'Евгений Онегин', 1, 'Художественная', 'Роман', 323, 1, 2000, 'Красивая книга');
-- CALL addbook('RU00002', 'Война и Мир', 2, 'Художественная', 'Роман', 100500, 2, 1992, 'Ужасная книга');
-- CALL addBook('RU00003', 'Финест - ясный сокол', 3, 'Художественная', 'Роман', 287, 3, '2015', 'Круто');
-- CALL addBook('RU00004', 'Сборник стихотворений', 1, 'Художественная', 'Стихотворение', 500, 2, '1999', 'Лучшее');

--CREATE USER bestt WITH SUPERUSER CREATEROLE PASSWORD '123';

--CREATE USER ksenya WITH PASSWORD '12345678';
--GRANT SELECT ON book, author, publisher, rental, reader, library, library_reader TO ksenya;
--GRANT UPDATE ON book, rental TO ksenya;
--GRANT INSERT ON rental TO ksenya;
-- CALL addReader('Матеуш', 'Ксения', '26.09.2000', 'Попова', '6', 'к3', 48, '175200', '88005553535', 'ksen@ya.ru', 'ksenya');


--CREATE USER dima WITH PASSWORD '12345678';
--GRANT SELECT ON book, author, publisher, rental, reader, library, library_reader TO dima;
--GRANT UPDATE ON book, rental TO dima;
--GRANT INSERT ON rental TO dima;
-- CALL addReader('Матеуш', 'Дмитрий', '14.01.2000', 'Попова', '6', 'к3', 48, '175200', '89116379054', 's246828@std.novsu.ru', 'dima');



---------------------------
--книги в наличии
CREATE VIEW library AS SELECT book.name, author.lastname || ' ' || author.firstname, book.theme, book.genre, book.count_pages, publisher.name as pn, book.publish_year, book.annotation, book.b_shifr, book.availability FROM book LEFT JOIN author ON author.id = book.author_id LEFT JOIN publisher ON publisher.id = book.publisher_id WHERE book.availability = True ORDER BY book.name;


--все книги
CREATE VIEW library_all AS SELECT book.name, author.lastname || ' ' || author.firstname, book.theme, book.genre, book.count_pages, publisher.name as pn, book.publish_year, book.annotation, book.b_shifr, book.availability FROM book LEFT JOIN author ON author.id = book.author_id LEFT JOIN publisher ON publisher.id = book.publisher_id ORDER BY book.name;



--Книги, которые взял пользователь
CREATE VIEW library_reader AS 
SELECT 
DISTINCT ON (book.b_shifr) book.name, author.lastname || ' ' || author.firstname, book.theme, book.genre, book.count_pages, publisher.name as pn, book.publish_year, book.annotation, book.b_shifr, book.availability 
FROM book LEFT JOIN author ON author.id = book.author_id 
LEFT JOIN publisher ON publisher.id = book.publisher_id 
JOIN rental ON book.b_shifr = rental.b_shifr
JOIN reader ON rental.reader_id = reader.id
WHERE reader.login = current_user AND rental.date_return IS null;
